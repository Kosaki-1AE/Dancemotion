version: 0.3
name: kansei_quantum_core
description: >
  Genesys–Stillness–Motion–Coherence (GSMC) のコア定義。GenesysはAI2の論文から引用って感じになると思う。
  責任ベクトルとノリエントロピーを共通の更新則・観測・記録に統合する。

units:
  time: s
  angle: rad
  freq: Hz
  entropy: nori   # 無次元だが "nori" として扱う擬似単位名
  magnitude: au   # arbitrary unit

state_space:
  layers:
    genesys:
      role: "前提・制約・資源の集合（設計図/環境モデル）"
      state:
        priors: {}         # 事前分布・前提 (任意のキー/値)
        constraints: []    # 制約式や境界条件
        resources: []      # 可用リソース（時間/注意/エネルギ等）
      update:
        rule: "G(t+Δ)=G(t) ⊕ ΔG"
        drivers: [coherence, motion, feedback]
        invariants: ["idempotent-like merges when Δ small"]
    stillness:
      role: "停止ではなく“静けさの秩序”と可逆余白（間）"
      state:
        coherence_time: { default: 1.0, unit: s }
        micro_fluct: { model: "OU", theta: 2.0, sigma: 0.1 } # 微ゆらぎ
        phase: { enum: [idle, observing, gating, holding], default: idle }
      metrics:
        stillness_in_motion: { range: [0,1] }
      interfaces:
        event_bus_topics:
          listen:
            - stillness.interrupt          # 外部割り込み（最優先）
            - stillness.tune               # 微調整（低優先）
            - sensor.*                     # センサ系全般
            - user.gesture                 # 人の所作・合図
          emit:
            - stillness.state_changed
            - stillness.probe_snapshot
        hooks:
          on_phase_enter: ["log", "probe.snapshot"]
          on_phase_exit:  ["log"]
          before_update:  ["apply.pending_interrupts"]
          after_update:   ["emit.state_changed"]
      interrupt:
        policy:
          preemptive: true                 # いつでも横取りOK
          granularity: "phase-level"       # フェーズ単位で割り込み
          latency_budget_ms: 15            # 入力→反映の目標遅延
          debounce_ms: 5                   # チャタリング吸収
          reentrancy: "queue"              # 多重割り込みはキュー化
          conflict_resolution: "priority_then_merge"  # 優先度→マージ
        priorities:                         # 高いほど強い
          stillness.interrupt: 100
          user.gesture: 80
          sensor.*: 60
          stillness.tune: 40
        safety:
          bounds:
            coherence_time: [0.05, 8.0]
            micro_fluct.sigma: [0.0, 0.8]
          rate_limits:
            interrupts_per_sec: 120
          rollback_on: ["nan", "overflow", "divergence"]
        merge_strategy:
          rule: "S(t+Δ)=clip( S(t) ⊕ δS_ext ⊕ δS_noise )"
          δS_ext:
            fields:
              phase_shift: { range: [-π, π], default: 0.0 }
              coherence_boost: { range: [-1, 1], default: 0.0 }
              sigma_scale: { range: [0.5, 1.5], default: 1.0 }
          noise: "OU"
        sandbox:
          enabled: true                     # 影響を仮適用→採否判定
          acceptance:
            tests: ["stability", "coherence_gain>=0", "latency<=latency_budget_ms"]
        update:
          rule: "∂S/∂t = f_s(G, M, C, noise) + Σ_i w_i·δS_i(t)"  # 外部注入を線形合成
          note: "δS_i は event_bus 由来の外乱/意図。w_i は priority 正規化。"
    motion:
      role: "実行と変化（行為・発話・身体運動）"
      state:
        action_intent: { type: "vector", dim: 3 } # 例: [amplitude, tempo, risk]
        executed: false
      update:
        rule: "∂M/∂t = u(t) - damping·M + coupling(C)"
        note: "実装側で離散化 (Δt) してOK"
    coherence:
      role: "各層間の整合・同期・伝達効率"
      state:
        coupling_matrix: "R^{n×n}"  # 層間結合の行列/グラフ
        bandwidth: { default: 1.0, unit: Hz }
      metrics:
        coherence_score: { range: [0,1] }
      update:
        rule: "C' = g(G,S,M,C; feedback)"
        remark: "同調/位相ロック/遅延補償を含む"

  responsibility_vector:
    definition:
      symbol: R
      space: "ℝ^k with labeled axes"
      axes: ["self", "other", "system"]   # 必要に応じて拡張
    constraints:
      non_neg: false
      conservation_like: "∑flows ≈ 0 over window unless external injection"
    update:
      rule: "R' = R + ΔR(G,S,M,C,observables)"
    metrics:
      magnitude: { unit: au }
      direction_cosines: {}
      accountability_score: { range: [0,1] }

  nori_entropy:
    meaning: "ノリエントロピー＝秩序ある“余白”に由来する意味を司るエントロピー"
    symbol: E_n
    invariant_measures:
      - name: "E*_window"
        window: { length: 10, unit: s }
        note: "同一プロトコル/同一目標条件下で不変近似を確認"
    decomposition:
      - "E_n = H(signal) - coherence_gain + responsibility_alignment_bonus"
    update:
      rule: "∂E_n/∂t = Φ(G,S,M,C; R, observables)"
      coupling_with_motion: "dM/dt ∝ dE_n/dt （実験条件下の仮説）"

observables:
  # 任意のドメインがここにマッピングする
  signals:
    - name: "audio"
      features: ["tempo", "onset_strength", "spectral_flux"]
    - name: "pose"
      features: ["velocity", "jerk", "freeze_ratio"]
  logging:
    frequency: 20   # Hz
    fields: ["time", "layer_states", "R", "E_n", "metrics"]

pipelines:
  scoring:
    stillness_in_motion: "σ(−|velocity| + freeze_ratio·β)"
    coherence_score: "phase_lock_index between layers/signals"
    responsibility:
      mapping: "context→axes (e.g., self/other/system)"
  adaptation:
    - name: "genesys_update_from_feedback"
      when: "coherence_score > θ and goal_gap reduced"
      do: "merge ΔG; update priors"

defaults:
  thresholds:
    coherence: 0.6
    stillness_in_motion: 0.5
  damping:
    motion: 0.1
